/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./examples/main.ts":
/*!**************************!*\
  !*** ./examples/main.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/math/vector2 */ \"./src/math/vector2.ts\");\n/* harmony import */ var _src_rendering_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/rendering/canvas */ \"./src/rendering/canvas.ts\");\n/* harmony import */ var _src_core_Scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/core/Scene */ \"./src/core/Scene.ts\");\n/* harmony import */ var _src_core_Entity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/core/Entity */ \"./src/core/Entity.ts\");\n\n\n\n\nconst baseEntities = [];\nfor (let i = 0; i < 100000; i++) {\n    const e = new _src_core_Entity__WEBPACK_IMPORTED_MODULE_3__.Entity();\n    e.z_index = Math.random() * 5000;\n    baseEntities.push(e);\n}\nconst numIter = 10;\nconst start = new Date();\nconst scene = new _src_core_Scene__WEBPACK_IMPORTED_MODULE_2__.Scene();\nscene.addEntities(baseEntities);\nfor (let n = 0; n < numIter; n++) {\n    const entities = [];\n    for (let j = 0; j < 50000; j++) {\n        const e = new _src_core_Entity__WEBPACK_IMPORTED_MODULE_3__.Entity();\n        e.z_index = Math.random() * 5000;\n        entities.push(e);\n    }\n    scene.addEntities(entities);\n}\nconst end = new Date();\nconsole.log(`Completed in ${(end.getTime() - start.getTime()) / numIter} ms`);\nconst canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\nif (canvas == null || ctx == null) {\n    throw new Error(\"Could not create canvas\");\n}\nconst renderer = new _src_rendering_canvas__WEBPACK_IMPORTED_MODULE_1__.CanvasRenderer(canvas, 100);\nconst st = new Date();\nlet mouseX = 0;\nlet mouseY = 0;\nfunction onMouseMove(event) {\n    mouseX = event.clientX;\n    mouseY = event.clientY;\n}\nwindow.addEventListener(\"mousemove\", onMouseMove);\nfunction test(num1, num2) {\n    console.log(num1);\n    console.log(num2);\n}\nfunction update() {\n    const ct = new Date().getTime() - st.getTime();\n    renderer.clear();\n    for (let i = -50; i < 50; i++) {\n        renderer.drawLine(new _src_math_vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(i, -50), new _src_math_vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(i, 50));\n        renderer.drawLine(new _src_math_vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(-50, i), new _src_math_vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(50, i));\n    }\n    const mousePos = new _src_math_vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(mouseX, mouseY);\n    ctx.font = \"30px Arial\";\n    ctx.fillText(`Canvas Position : ${new _src_math_vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(canvas.offsetLeft, canvas.offsetTop).toString()}`, 0, 30);\n    ctx.fillText(`Canvas Size : ${new _src_math_vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(canvas.width, canvas.height).toString()}`, 0, 60);\n    ctx.fillText(`Window Mouse : ${mousePos.toString()}`, 0, 90);\n    ctx.fillText(`Canvas Mouse : ${renderer.tWindowToCanvas(mousePos).toString()}`, 0, 120);\n    ctx.fillText(`World Mouse : ${renderer.tWindowToWorld(mousePos).toString()}`, 0, 150);\n    requestAnimationFrame(update);\n}\nupdate();\n\n\n//# sourceURL=webpack://@max_feige/canvas-utils/./examples/main.ts?");

/***/ }),

/***/ "./src/core/Entity.ts":
/*!****************************!*\
  !*** ./src/core/Entity.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Entity: () => (/* binding */ Entity)\n/* harmony export */ });\n/* harmony import */ var _math_transform2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/transform2d */ \"./src/math/transform2d.ts\");\n//Disable these warnings for this file since update and draw are meant to be overriden\n/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nclass Entity {\n    constructor() {\n        this.transform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Identity;\n        this.z_index = 0;\n    }\n    update(dt) {\n    }\n    draw(dt) {\n    }\n}\n\n\n//# sourceURL=webpack://@max_feige/canvas-utils/./src/core/Entity.ts?");

/***/ }),

/***/ "./src/core/Scene.ts":
/*!***************************!*\
  !*** ./src/core/Scene.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scene: () => (/* binding */ Scene)\n/* harmony export */ });\nclass Scene {\n    constructor() {\n        this.entities = [];\n    }\n    //Insertion sort, as the entities list should be nearly sorted at all times (except maybe load)\n    sortEntities() {\n        let j = 0;\n        for (let i = 1; i < this.entities.length; i++) {\n            j = i - 1;\n            const current = this.entities[i].z_index;\n            while ((j >= 0) && (current < this.entities[j].z_index)) {\n                this.entities[j + 1] = this.entities[j];\n                j--;\n            }\n            this.entities[j + 1] = this.entities[current];\n        }\n    }\n    /**\n     * This is more efficient when adding very few entities - i.e. 1 or 2 at a time\n     * @param entity\n     */\n    addSingleEntity(entity) {\n        //To efficiently put this in we use binary search to find the greatest element less than our entities z-indexx\n        let left = 0;\n        let right = this.entities.length - 1;\n        let index = 0;\n        let mid = 0;\n        while (left <= right) {\n            mid = Math.floor((left + right) / 2);\n            if (this.entities[mid].z_index < entity.z_index) {\n                left = mid + 1;\n                index = left;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n        this.entities.splice(index, 0, entity);\n    }\n    //Either adds via binary search + insertion, or push + sort depending on size of entiteies\n    addEntities(entities) {\n        //If the given entities are more than 25% of the current entities, we sort.\n        //Otherwise we add them oen at a time\n        if (this.entities.length * 0.25 > entities.length) {\n            this.entities.push(...entities);\n            this.entities.sort((a, b) => a.z_index - b.z_index);\n            return;\n        }\n        this.entities.forEach((entity) => this.addSingleEntity(entity));\n    }\n    removeEntity(entity) {\n        //TODO: Right efficient binary search on z-index to find entity\n        const index = this.entities.indexOf(entity);\n        if (index === -1) {\n            return false;\n        }\n        this.entities.splice(index, 1);\n        return true;\n    }\n    update(dt) {\n        this.entities.forEach(entity => entity.update(dt));\n    }\n    draw(dt) {\n        this.entities.forEach((entity) => entity.draw(dt));\n    }\n}\n\n\n//# sourceURL=webpack://@max_feige/canvas-utils/./src/core/Scene.ts?");

/***/ }),

/***/ "./src/math/linked_math.ts":
/*!*********************************!*\
  !*** ./src/math/linked_math.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinkedVector2: () => (/* binding */ LinkedVector2)\n/* harmony export */ });\n/* harmony import */ var _vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vector2 */ \"./src/math/vector2.ts\");\n\n//Vector2 with callback on changes\nclass LinkedVector2 extends _vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2 {\n    constructor(x, y, _callbackX, _callbackY) {\n        super(x, y);\n        this._callbackX = _callbackX;\n        this._callbackY = _callbackY;\n    }\n    //Apparently we need our own get/set, not inheriting...\n    get x() {\n        return this._x;\n    }\n    set x(val) {\n        this._x = val;\n        this._callbackX(this._x);\n    }\n    get y() {\n        return this._y;\n    }\n    set y(val) {\n        this._y = val;\n        this._callbackY(this._y);\n    }\n    toVector2() {\n        return new _vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(this._x, this._y);\n    }\n}\n\n\n//# sourceURL=webpack://@max_feige/canvas-utils/./src/math/linked_math.ts?");

/***/ }),

/***/ "./src/math/transform2d.ts":
/*!*********************************!*\
  !*** ./src/math/transform2d.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform2D: () => (/* binding */ Transform2D)\n/* harmony export */ });\n/* harmony import */ var _vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vector2 */ \"./src/math/vector2.ts\");\n/* harmony import */ var _linked_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linked_math */ \"./src/math/linked_math.ts\");\n/* harmony import */ var _utility__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utility */ \"./src/math/utility.ts\");\n\n\n\n//TODO: .equals\n/**\n * Represents a 2D transform (position, rotation, scale)\n */\nclass Transform2D {\n    /**\n   * Create a TransformMatrix2D.\n   * @param m11 - The value for row 1, column 1 of the matrix.\n   * @param m12 - The value for row 1, column 2 of the matrix.\n   * @param m13 - The value for row 1, column 3 of the matrix.\n   * @param m21 - The value for row 2, column 1 of the matrix.\n   * @param m22 - The value for row 2, column 2 of the matrix.\n   * @param m23 - The value for row 2, column 3 of the matrix.\n   * @param m31 - The value for row 3, column 1 of the matrix.\n   * @param m32 - The value for row 3, column 2 of the matrix.\n   * @param m33 - The value for row 3, column 3 of the matrix.\n   */\n    constructor(m11, m12, m13, m21, m22, m23, m31, m32, m33) {\n        this.values = [m11, m12, m13, m21, m22, m23, m31, m32, m33];\n        this._position = new _linked_math__WEBPACK_IMPORTED_MODULE_1__.LinkedVector2(this.values[2], this.values[5], this.onSetPositionX.bind(this), this.onSetPositionY.bind(this));\n        const calcScale = this.calculateScale();\n        this._scale = new _linked_math__WEBPACK_IMPORTED_MODULE_1__.LinkedVector2(calcScale.x, calcScale.y, this.onSetScaleX.bind(this), this.onSetScaleY.bind(this));\n        this._rotation = this.calculateRotation();\n    }\n    //#region POSITION\n    onSetPositionX(value) {\n        this.values[2] = value;\n    }\n    onSetPositionY(value) {\n        this.values[5] = value;\n    }\n    updateLinkedPosition() {\n        //Update directly the values there, thus ignoring the set / get methods\n        //This way we don't callback recursively.\n        this._position[\"_x\"] = this.values[2];\n        this._position[\"_y\"] = this.values[5];\n    }\n    get position() {\n        return this._position;\n    }\n    set position(pos) {\n        this.values[2] = pos.x;\n        this.values[5] = pos.y;\n        this.updateLinkedPosition();\n    }\n    //#endregion\n    //#region ROTATION\n    //Updates the rotation value.  Called when rotation is changed elsewhere in code\n    updateLinkedRotation(value) {\n        this._rotation = value;\n    }\n    calculateRotation() {\n        return Math.atan2(-this.values[1], this.values[0]);\n    }\n    get rotation() {\n        return this._rotation;\n    }\n    set rotation(val) {\n        const currentScale = this._scale;\n        //NOTE: Negate val for counter clockwise rotation\n        const sin = Math.sin(-val);\n        const cos = Math.cos(-val);\n        this.values[0] = cos * currentScale.x;\n        this.values[1] = sin * currentScale.x;\n        this.values[3] = -sin * currentScale.y;\n        this.values[4] = cos * currentScale.y;\n        this.updateLinkedRotation(val);\n    }\n    //#endregion\n    //#region scale\n    //TODO: Consider doing this piecewise for perfo\n    updateLinkedScale(vec) {\n        this._scale[\"_x\"] = vec.x;\n        this._scale[\"_y\"] = vec.y;\n    }\n    calculateScale() {\n        return new _vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(Math.sqrt(this.values[0] * this.values[0] + this.values[1] * this.values[1]), Math.sqrt(this.values[3] * this.values[3] + this.values[4] * this.values[4]));\n    }\n    onSetScaleX(x) {\n        let currentX = this._scale.x;\n        const currentRotation = this.rotation;\n        if (currentX === 0) {\n            this.values[0] = Math.cos(currentRotation);\n            this.values[1] = Math.sin(currentRotation);\n            currentX = 1;\n        }\n        this.values[0] *= x / currentX;\n        this.values[1] *= x / currentX;\n        this.updateLinkedScale(new _vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, this.scale.y));\n    }\n    onSetScaleY(y) {\n        let currentY = this._scale.x;\n        const currentRotation = this.rotation;\n        if (currentY === 0) {\n            this.values[3] = Math.cos(currentRotation);\n            this.values[4] = Math.sin(currentRotation);\n            currentY = 1;\n        }\n        this.values[3] *= y / currentY;\n        this.values[4] *= y / currentY;\n        this.updateLinkedScale(new _vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(this.scale.x, y));\n    }\n    get scale() {\n        return this._scale;\n    }\n    set scale(scale) {\n        const current_scale = this._scale;\n        const currentRotation = this._rotation;\n        //Reset to identity if so\n        if (current_scale.x === 0) {\n            this.values[0] = Math.cos(currentRotation);\n            this.values[1] = Math.sin(currentRotation);\n            current_scale.x = 1;\n        }\n        if (current_scale.y === 0) {\n            this.values[3] = Math.sin(currentRotation);\n            this.values[4] = Math.cos(currentRotation);\n            current_scale.y = 1;\n        }\n        this.values[0] *= scale.x / current_scale.x;\n        this.values[1] *= scale.x / current_scale.x;\n        this.values[3] *= scale.y / current_scale.y;\n        this.values[4] *= scale.y / current_scale.y;\n        this.updateLinkedScale(scale);\n    }\n    //#endregion\n    //#region Calculations\n    updateAll() {\n        this.updateLinkedPosition();\n        this.updateLinkedRotation(this.calculateRotation());\n        this.updateLinkedScale(this.calculateScale());\n    }\n    /**\n    Calculates the inverse of this transform.  To invert in place see {@link invert}\n    @returns {Transform2D} The inverse of the current transform matrix.\n    */\n    inverse() {\n        const A = this.values[4] * this.values[8] - this.values[5] * this.values[7];\n        const B = this.values[5] * this.values[6] - this.values[3] * this.values[8];\n        const C = this.values[3] * this.values[7] - this.values[4] * this.values[6];\n        const det = this.values[0] * A + this.values[1] * B + this.values[2] * C;\n        if (det === 0) {\n            return new Transform2D(0, 0, 0, 0, 0, 0, 0, 0, 0);\n        }\n        const D = this.values[2] * this.values[7] - this.values[1] * this.values[8];\n        const E = this.values[0] * this.values[8] - this.values[2] * this.values[6];\n        const F = this.values[1] * this.values[6] - this.values[0] * this.values[7];\n        const G = this.values[1] * this.values[5] - this.values[2] * this.values[4];\n        const H = this.values[2] * this.values[3] - this.values[0] * this.values[5];\n        const I = this.values[0] * this.values[4] - this.values[1] * this.values[3];\n        //The mnatrix [A,B,C,D,E,F,G,H,I] is the adj matrix\n        //We want the transpose\n        const detInv = 1 / det;\n        return new Transform2D(detInv * A, detInv * D, detInv * G, detInv * B, detInv * E, detInv * H, detInv * C, detInv * F, detInv * I);\n    }\n    /**\n     * Modifies current transform to be its inverse.  To get inverse without changing source see {@link inverse}\n     * @returns Self\n     */\n    invert() {\n        const A = this.values[4] * this.values[8] - this.values[5] * this.values[7];\n        const B = this.values[5] * this.values[6] - this.values[3] * this.values[8];\n        const C = this.values[3] * this.values[7] - this.values[4] * this.values[6];\n        const det = this.values[0] * A + this.values[1] * B + this.values[2] * C;\n        if (det === 0) {\n            for (let i = 0; i < this.values.length; i++) {\n                this.values[i] = 0;\n            }\n            this.updateAll();\n            return this;\n        }\n        const D = this.values[2] * this.values[7] - this.values[1] * this.values[8];\n        const E = this.values[0] * this.values[8] - this.values[2] * this.values[6];\n        const F = this.values[1] * this.values[6] - this.values[0] * this.values[7];\n        const G = this.values[1] * this.values[5] - this.values[2] * this.values[4];\n        const H = this.values[2] * this.values[3] - this.values[0] * this.values[5];\n        const I = this.values[0] * this.values[4] - this.values[1] * this.values[3];\n        //The mnatrix [A,B,C,D,E,F,G,H,I] is the adj matrix\n        //We want the transpose\n        const detInv = 1 / det;\n        this.values[0] = detInv * A;\n        this.values[1] = detInv * D;\n        this.values[2] = detInv * G;\n        this.values[3] = detInv * B;\n        this.values[4] = detInv * E;\n        this.values[5] = detInv * H;\n        this.values[6] = detInv * C;\n        this.values[7] = detInv * F;\n        this.values[8] = detInv * I;\n        this.updateAll();\n        return this;\n    }\n    //Creates a new transform, applying the given transform to self\n    apply(transform) {\n        return Transform2D.Apply(transform, this);\n    }\n    /**\n     * Modifies the current matrix to be transformed by the given transformation\n     * @param transformation Transformation to apply to self\n     * @returns this\n     */\n    applyS(transform) {\n        const m1 = transform.values;\n        const a = m1[0] * this.values[0] + m1[1] * this.values[3] + m1[2] * this.values[6];\n        const b = m1[0] * this.values[1] + m1[1] * this.values[4] + m1[2] * this.values[7];\n        const c = m1[0] * this.values[2] + m1[1] * this.values[5] + m1[2] * this.values[8];\n        const d = m1[3] * this.values[0] + m1[4] * this.values[3] + m1[5] * this.values[6];\n        const e = m1[3] * this.values[1] + m1[4] * this.values[4] + m1[5] * this.values[7];\n        const f = m1[3] * this.values[2] + m1[4] * this.values[5] + m1[5] * this.values[8];\n        const g = m1[6] * this.values[0] + m1[7] * this.values[3] + m1[8] * this.values[6];\n        const h = m1[6] * this.values[1] + m1[7] * this.values[4] + m1[8] * this.values[7];\n        const i = m1[6] * this.values[2] + m1[7] * this.values[5] + m1[8] * this.values[8];\n        this.values[0] = a;\n        this.values[1] = b;\n        this.values[2] = c;\n        this.values[3] = d;\n        this.values[4] = e;\n        this.values[5] = f;\n        this.values[6] = g;\n        this.values[7] = h;\n        this.values[8] = i;\n        this.updateAll();\n        return this;\n    }\n    /**\n     * Apply this transform to a point, essentially getting the points position relative to this transform\n     * @param vector2 point to transform\n     * @returns a new vector2 transformed from the original\n     */\n    applyPoint(vector2) {\n        return new _vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(this.values[0] * vector2.x + this.values[1] * vector2.y + this.values[2], this.values[3] * vector2.x + this.values[4] * vector2.y + this.values[5]);\n    }\n    /**\n     *\n     * @param other The transform to compare to\n     * @param {number} [tolerance=MathU.DefaultErrorMargin] - The tolerance for the comparison\n     * @returns {boolean} True if the matrices are completely equal\n     */\n    equals(other, tolerance = _utility__WEBPACK_IMPORTED_MODULE_2__.MathU.DefaultErrorMargin) {\n        return this.values.every((val, i) => Math.abs(val - other.values[i]) <= tolerance);\n    }\n    //#endregion\n    //#region Generation of basic transforms\n    /**\n * Create a transformation matrix with a given position.\n * @param pos - The position for the transformation matrix.\n * @returns A new TransformMatrix2D.\n */\n    static FromPosition(pos) {\n        return new Transform2D(1, 0, pos.x, 0, 1, pos.y, 0, 0, 1);\n    }\n    //TODO: Consider switching constructor/create?\n    /**\n * Create a transformation matrix with a given rotation.\n * @param theta - The rotation angle in radians.\n * @returns A new TransformMatrix2D.\n */\n    static Create(position, rotation, scale) {\n        //TODO: consider performance here?\n        const transform = Transform2D.Identity;\n        transform.position = position;\n        transform.rotation = rotation;\n        transform.scale = scale;\n        return transform;\n    }\n    static FromRotation(theta) {\n        const cos = Math.cos(theta);\n        const sin = Math.sin(theta);\n        return new Transform2D(cos, -sin, 0, sin, cos, 0, 0, 0, 1);\n    }\n    /**\n   * Create a transformation matrix with a given rotation.\n   * @param theta - The rotation angle in degrees.\n   * @returns A new TransformMatrix2D.\n   */\n    static FromRotationDegrees(theta) {\n        return Transform2D.FromRotation(theta * Math.PI / 180);\n    }\n    /**\n   * Create a transformation matrix with a given scale.\n   * @param scale - The scale for the transformation matrix. It can be a number or a Vector2.\n   * @returns A new TransformMatrix2D.\n   */\n    static FromScalar(scale) {\n        if (typeof scale === \"number\") {\n            return new Transform2D(scale, 0, 0, 0, scale, 0, 0, 0, 1);\n        }\n        return new Transform2D(scale.x, 0, 0, 0, scale.y, 0, 0, 0, 1);\n    }\n    //#endregion\n    //#region Operations\n    /**\n * Apply a transformation matrix to another matrix.  Performs the operation transform * subject\n * @param transform - The transformation matrix to apply.\n * @param subject - The matrix to which the transformation is applied.\n * @returns A new TransformMatrix2D that is the result of the transformation.\n */\n    static Apply(transform, subject) {\n        const m1 = transform.values;\n        const m2 = subject.values;\n        return new Transform2D(m1[0] * m2[0] + m1[1] * m2[3] + m1[2] * m2[6], m1[0] * m2[1] + m1[1] * m2[4] + m1[2] * m2[7], m1[0] * m2[2] + m1[1] * m2[5] + m1[2] * m2[8], m1[3] * m2[0] + m1[4] * m2[3] + m1[5] * m2[6], m1[3] * m2[1] + m1[4] * m2[4] + m1[5] * m2[7], m1[3] * m2[2] + m1[4] * m2[5] + m1[5] * m2[8], m1[6] * m2[0] + m1[7] * m2[3] + m1[8] * m2[6], m1[6] * m2[1] + m1[7] * m2[4] + m1[8] * m2[7], m1[6] * m2[2] + m1[7] * m2[5] + m1[8] * m2[8]);\n    }\n    /**\n     * Apply a transform matrix to a point, essentially getting the points position relative to the transform\n     * @param transform transform to use\n     * @param vector2 point to transform\n     * @returns a new vector2 transformed from the original\n     */\n    static ApplyPoint(transform, vector2) {\n        return new _vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(transform.values[0] * vector2.x + transform.values[1] * vector2.y + transform.values[2], transform.values[3] * vector2.x + transform.values[4] * vector2.y + transform.values[5]);\n    }\n    /**\n\n    Calculates the inverse of the given 2D transform matrix.\n    @returns {Transform2D} The inverse of the current transform matrix.\n    */\n    static Inverse(transform) {\n        return transform.inverse();\n    }\n    /**\n     * Check if two transform matrices have the same values\n     * @param t1 first transform\n     * @param t2 second transform\n     * @param {number} [tolerance=MathU.DefaultErrorMargin] - The tolerance for the comparison\n     * @returns {boolean} true if matrices exactly match\n     */\n    static Equals(t1, t2, tolerance = _utility__WEBPACK_IMPORTED_MODULE_2__.MathU.DefaultErrorMargin) {\n        return t1.values.every((val, i) => Math.abs(val - t2.values[i]) <= tolerance);\n    }\n    //#endregion\n    /**\n     * Create an identity transformation matrix.\n     * @returns {Transform2D} A New identity TransformMatrix2D.\n     */\n    static get Identity() {\n        return new Transform2D(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    }\n    /**\n     * Create a 0 transform matrix\n     * @returns {Transform2D} a new zero transform\n     */\n    static get Zero() {\n        return new Transform2D(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    /**\n     *\n     * @returns {string} An array representation of the values of the transform\n     */\n    toString() {\n        return `[${this.values[0]},${this.values[1]},${this.values[2]}],\n[${this.values[3]},${this.values[4]},${this.values[5]}],\n[${this.values[6]},${this.values[7]},${this.values[8]}],`;\n    }\n}\n\n\n//# sourceURL=webpack://@max_feige/canvas-utils/./src/math/transform2d.ts?");

/***/ }),

/***/ "./src/math/utility.ts":
/*!*****************************!*\
  !*** ./src/math/utility.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MathU: () => (/* binding */ MathU)\n/* harmony export */ });\nclass MathU {\n    static clamp(value, min, max) {\n        return Math.max(min, Math.min(value, max));\n    }\n}\nMathU.DefaultErrorMargin = 0.0001;\n\n\n//# sourceURL=webpack://@max_feige/canvas-utils/./src/math/utility.ts?");

/***/ }),

/***/ "./src/math/vector2.ts":
/*!*****************************!*\
  !*** ./src/math/vector2.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector2: () => (/* binding */ Vector2)\n/* harmony export */ });\n/* harmony import */ var _utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utility */ \"./src/math/utility.ts\");\n\n/**\n * Class representing a 2d vector\n */\nclass Vector2 {\n    /**\n     * Create a new Vector2 object\n     * @param {number} x - The X component of the vector\n     * @param {number} y - The Y component of the vector\n     */\n    constructor(x, y) {\n        this._x = x;\n        this._y = y;\n    }\n    /**\n     * Get the X component of the vector\n     * @return {number} The X component of the vector\n     */\n    get x() {\n        return this._x;\n    }\n    /**\n     * Set the X component of the vector\n     * @param {number} val - The new X component value\n     */\n    set x(val) {\n        this._x = val;\n    }\n    /**\n     * Get the Y component of the vector\n     * @return {number} The Y component of the vector\n     */\n    get y() {\n        return this._y;\n    }\n    /**\n     * Set the Y component of the vector\n     * @param {number} val - The new Y component value\n     */\n    set y(val) {\n        this._y = val;\n    }\n    add(other) {\n        return Vector2.Add(this, other);\n    }\n    /**\n     * Add another vector to this vector\n     * @param {Vector2} other - The other vector\n     * @returns {Vector2} The modified original vector\n     */\n    addS(other) {\n        this.x += other.x;\n        this.y += other.y;\n        return this;\n    }\n    subtract(other) {\n        return Vector2.Subtract(this, other);\n    }\n    /**\n     * Subtract another vector from this vector\n     * @param {Vector2} other - The other vector\n     * @returns {Vector2} The modified original vector\n     */\n    subtractS(other) {\n        this.x -= other.x;\n        this.y -= other.y;\n        return this;\n    }\n    multiply(value) {\n        return Vector2.Multiply(this, value);\n    }\n    /**\n     * Multiply this vector by a scalar or another vector\n     * @param {number | Vector2} value - The scalar or vector to multiply by\n     * @returns {Vector2} The modified original vector\n     */\n    multiplyS(value) {\n        if (typeof value === \"number\") {\n            this.x *= value;\n            this.y *= value;\n            return this;\n        }\n        this.x *= value.x;\n        this.y *= value.y;\n        return this;\n    }\n    divide(value) {\n        return Vector2.Divide(this, value);\n    }\n    /**\n     * Divide this vector by a scalar or another vector\n     * @param {number | Vector2} value - The scalar or vector to divide by\n     * @returns {Vector2} The modified original vector\n     */\n    divideS(value) {\n        if (typeof value === \"number\") {\n            this.x /= value;\n            this.y /= value;\n            return this;\n        }\n        this.x /= value.x;\n        this.y /= value.y;\n        return this;\n    }\n    min(other) {\n        return Vector2.Max(this, other);\n    }\n    /**\n     * Set the components of this vector to the minimum of their current values and the corresponding values of another vector\n     * @param {Vector2} other - The other vector\n     * @returns {Vector2} The modified original vector\n     */\n    minS(other) {\n        this.x = Math.min(this.x, other.x);\n        this.y = Math.min(this.y, other.y);\n        return this;\n    }\n    max(other) {\n        return Vector2.Max(this, other);\n    }\n    /**\n     * Set the components of this vector to the maximum of their current values and the corresponding values of another vector\n     * @param {Vector2} other - The other vector\n     * @returns {Vector2} The modified original vector\n     */\n    maxS(other) {\n        this.x = Math.max(this.x, other.x);\n        this.y = Math.max(this.y, other.y);\n        return this;\n    }\n    /**\n     * Get the length (magnitude) of this vector\n     * @returns {number} The length of the vector\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    /**\n     * Get the squared length of this vector\n     * @returns {number} The squared length of the vector\n     */\n    lengthSq() {\n        return this.x * this.x + this.y * this.y;\n    }\n    /**\n     * Calculate the dot product of this vector and another vector\n     * @param {Vector2} other - The other vector\n     * @returns {number} The dot product of the two vectors\n     */\n    dot(other) {\n        return this.x * other.x + this.y * other.y;\n    }\n    /**\n     * Perpendicularizes the vector\n     * @returns {Vector2} The modified original vector\n     */\n    perpendicularizeS() {\n        const tmp = this.x;\n        this.x = -this.y;\n        this.y = tmp;\n        return this;\n    }\n    perpendicularize() {\n        return new Vector2(-this.y, this.x);\n    }\n    /**\n     * Calculates the angle between this vector and the x-axis\n     * @returns {number} The angle in radians\n     */\n    angle() {\n        //Clever way to get an angle between 0 and 360 with the x axis\n        return Math.atan2(-this.y, this.x) + +(this.y > 0) * 2 * Math.PI;\n    }\n    /**\n     * Calculates the angle between this vector and another vector\n     * @param {Vector2} other - The other vector\n     * @returns {number} The angle in radians\n     */\n    angleTo(other) {\n        const d = Math.sqrt(other.lengthSq() * this.lengthSq());\n        if (d === 0) {\n            return Math.PI / 2;\n        }\n        //Floating point errors can cause weird issues\n        const theta = _utility__WEBPACK_IMPORTED_MODULE_0__.MathU.clamp(this.dot(other) / d, -1, 1);\n        return Math.acos(theta);\n    }\n    /**\n     * Calculates the distance from this vector to another vector\n     * @param {Vector2} other - The other vector\n     * @returns {number} The distance\n     */\n    distanceTo(other) {\n        const dx = this.x - other.x;\n        const dy = this.y - other.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    /**\n     * Calculates the squared distance from this vector to another vector\n     * @param {Vector2} other - The other vector\n     * @returns {number} The squared distance\n     */\n    distanceToSquared(other) {\n        const dx = this.x - other.x;\n        const dy = this.y - other.y;\n        return dx * dx + dy * dy;\n    }\n    lerp(other, t) {\n        return Vector2.Lerp(this, other, t);\n    }\n    /**\n     * Performs a linear interpolation between this vector and another vector\n     * @param {Vector2} other - The other vector\n     * @param {number} t - The interpolation factor\n     * @returns {Vector2} The modified original vector\n     */\n    lerpS(other, t) {\n        this.x = this.x + (other.x - this.x) * t;\n        this.y = this.y + (other.y - this.y) * t;\n        return this;\n    }\n    /**\n     * Creates a copy of this vector\n     * @returns {Vector2} The new vector copy\n     */\n    copy() {\n        return new Vector2(this.x, this.y);\n    }\n    /**\n     * Checks if this vector is equal to another vector within a certain tolerance\n     * @param {Vector2} other - The other vector\n     * @param {number} [tolerance=MathU.DefaultErrorMargin] - The tolerance for the comparison\n     * @returns {boolean} True if the vectors are equal within the tolerance, false otherwise\n     */\n    equals(other, tolerance = _utility__WEBPACK_IMPORTED_MODULE_0__.MathU.DefaultErrorMargin) {\n        return (Math.abs(this.x - other.x) <= tolerance &&\n            Math.abs(this.y - other.y) <= tolerance);\n    }\n    /**\n     * Iterator for the Vector2 class. Allows for the use of the 'for ... of' loop.\n     * @returns {Generator<number>} A Generator yielding the x and y components of the Vector2 instance.\n     */\n    *[Symbol.iterator]() {\n        yield this.x;\n        yield this.y;\n    }\n    /**\n     * Returns the string representation of the Vector2 instance. This method is called by JavaScript\n     * when converting an object to a string using the built-in `toString` function.\n     * @returns {string} The string representation of the Vector2 instance.\n     */\n    get [Symbol.toStringTag]() {\n        return this.toString();\n    }\n    /**\n     * Returns the string representation of the Vector2 instance.\n     * @returns {string} The string representation of the Vector2 instance.\n     */\n    toString() {\n        return `(${this._x},${this._y})`;\n    }\n    /**\n     * Convert number to an array/tuple\n     * @returns The vector as a two number tuple\n     */\n    toArray() {\n        return [this._x, this._y];\n    }\n    /**\n     * Returns a new Vector2 instance initialized to (0, 0).\n     * @returns {Vector2} A Vector2 instance representing the origin.\n     */\n    static get Zero() {\n        return new Vector2(0, 0);\n    }\n    /**\n     * Returns a new Vector2 instance initialized to (-1, 0).\n     * @returns {Vector2} A Vector2 instance representing left direction.\n     */\n    static get Left() {\n        return new Vector2(-1, 0);\n    }\n    /**\n     * Returns a new Vector2 instance initialized to (1, 0).\n     * @returns {Vector2} A Vector2 instance representing right direction.\n     */\n    static get Right() {\n        return new Vector2(1, 0);\n    }\n    /**\n     * Returns a new Vector2 instance initialized to (0, -1).\n     * @returns {Vector2} A Vector2 instance representing up direction.\n     */\n    static get Up() {\n        return new Vector2(0, -1);\n    }\n    /**\n     * Returns a new Vector2 instance initialized to (0, 1).\n     * @returns {Vector2} A Vector2 instance representing down direction.\n     */\n    static get Down() {\n        return new Vector2(0, 1);\n    }\n    /**\n     * Adds two Vector2 instances together and returns the result as a new Vector2.\n     * @param {Vector2} v1 - The first vector.\n     * @param {Vector2} v2 - The second vector.\n     * @returns {Vector2} A new Vector2 instance representing the sum of the input vectors.\n     */\n    static Add(v1, v2) {\n        return new Vector2(v1.x + v2.x, v1.y + v2.y);\n    }\n    /**\n     * Subtracts the second Vector2 from the first and returns the result as a new Vector2.\n     * @param {Vector2} v1 - The vector to subtract from.\n     * @param {Vector2} v2 - The vector to subtract.\n     * @returns {Vector2} A new Vector2 instance representing the difference of the input vectors.\n     */\n    static Subtract(v1, v2) {\n        return new Vector2(v1.x - v2.x, v1.y - v2.y);\n    }\n    /**\n     * Multiplies a Vector2 by a scalar or another Vector2 and returns the result as a new Vector2.\n     * @param {Vector2} vector - The vector to multiply.\n     * @param {number | Vector2} scalar - The scalar or vector to multiply by.\n     * @returns {Vector2} A new Vector2 instance representing the product of the input vector and scalar.\n     */\n    static Multiply(vector, scalar) {\n        if (typeof scalar === \"number\") {\n            return new Vector2(vector.x * scalar, vector.y * scalar);\n        }\n        return new Vector2(vector.x * scalar.x, vector.y * scalar.y);\n    }\n    /**\n     * Divides a Vector2 by a scalar or another Vector2 and returns the result as a new Vector2.\n     * @param {Vector2} vector - The vector to divide.\n     * @param {number | Vector2} scalar - The scalar or vector to divide by.\n     * @returns {Vector2} A new Vector2 instance representing the quotient of the input vector and scalar.\n     */\n    static Divide(vector, scalar) {\n        if (typeof scalar === \"number\") {\n            return new Vector2(vector.x / scalar, vector.y / scalar);\n        }\n        return new Vector2(vector.x / scalar.x, vector.y / scalar.y);\n    }\n    /**\n     * Returns a new Vector2 that is the component-wise minimum of the input vectors.\n     * @param {Vector2} v1 - The first vector.\n     * @param {Vector2} v2 - The second vector.\n     * @returns {Vector2} A new Vector2 instance representing the component-wise minimum of the input vectors.\n     */\n    static Min(v1, v2) {\n        return new Vector2(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y));\n    }\n    /**\n     * Returns a new Vector2 that is the component-wise maximum of the input vectors.\n     * @param {Vector2} v1 - The first vector.\n     * @param {Vector2} v2 - The second vector.\n     * @returns {Vector2} A new Vector2 instance representing the component-wise maximum of the input vectors.\n     */\n    static Max(v1, v2) {\n        return new Vector2(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y));\n    }\n    /**\n     * Computes the dot product of two vectors.\n     * @param {Vector2} v1 - The first vector.\n     * @param {Vector2} v2 - The second vector.\n     * @returns {number} The dot product of the input vectors.\n     */\n    static Dot(v1, v2) {\n        return v1.x * v2.x + v1.y * v2.y;\n    }\n    /**\n     * Computes the length (magnitude) of a vector.\n     * @param {Vector2} vector - The vector to compute the length of.\n     * @returns {number} The length of the vector.\n     */\n    static Length(vector) {\n        return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n    }\n    /**\n     * Computes the squared length of a vector.\n     * @param {Vector2} vector - The vector to compute the squared length of.\n     * @returns {number} The squared length of the vector.\n     */\n    static LengthSq(vector) {\n        return vector.x * vector.x + vector.y * vector.y;\n    }\n    /**\n     * Computes the angle in radians of a vector relative to the x-axis.\n     * @param {Vector2} vector - The vector to compute the angle of.\n     * @returns {number} The angle of the vector, in radians.\n     */\n    static Angle(vector) {\n        return Math.atan2(-vector.y, vector.x) + +(vector.y > 0) * 2 * Math.PI;\n    }\n    /**\n     * Computes the angle in radians between two vectors.\n     * @param {Vector2} v1 - The first vector.\n     * @param {Vector2} v2 - The second vector.\n     * @returns {number} The angle between the vectors, in radians.\n     */\n    static AngleBetween(v1, v2) {\n        const d = Math.sqrt(v2.lengthSq() * v1.lengthSq());\n        if (d === 0) {\n            return Math.PI / 2;\n        }\n        //Floating point errors can cause weird issues\n        const theta = _utility__WEBPACK_IMPORTED_MODULE_0__.MathU.clamp(v1.dot(v2) / d, -1, 1);\n        return Math.acos(theta);\n    }\n    /**\n     * Creates a new vector perpendicular to the input vector\n     * @param {Vector2} v1 - Input vector\n     * @returns {Vector2} The new perpendicular vector\n     */\n    static Perpendicular(v1) {\n        return new Vector2(-v1.y, v1.x);\n    }\n    static DistanceBetween(v1, v2) {\n        const dx = v1.x - v2.x;\n        const dy = v1.y - v2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    static DistanceBetweenSquared(v1, v2) {\n        const dx = v1.x - v2.x;\n        const dy = v1.y - v2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    /**\n     * Alias for {@link DistanceBetween}\n     * @param v1 source vector\n     * @param v2 goal vector\n     * @returns distance between the two vectors\n    */\n    static DistanceTo(v1, v2) {\n        return Vector2.DistanceBetween(v1, v2);\n    }\n    /**\n     * Alias for {@link DistanceBetweenSquared}\n     * @param v1 source vector\n     * @param v2 goal vector\n     * @returns distance squared between the two vectors\n    */\n    static DistanceToSquared(v1, v2) {\n        return Vector2.DistanceBetweenSquared(v1, v2);\n    }\n    /**\n     * Performs a linear interpolation between two vectors.\n     * @param {Vector2} v1 - The first vector.\n     * @param {Vector2} v2 - The second vector.\n     * @param {number} t - The interpolation factor. 0 will return v1, 1 will return v2.\n     * @returns {Vector2} The interpolated vector.\n     */\n    static Lerp(v1, v2, t) {\n        return this.Add(v1, this.Subtract(v2, v1).multiplyS(t));\n    }\n    /**\n     * Generates a random vector within a square of side length 2, centered at the origin.\n     * @returns {Vector2} The generated vector.\n     */\n    static RandomSquare() {\n        return new Vector2(Math.random() * 2 - 1, Math.random() * 2 - 1);\n    }\n    /**\n     * Generates a random vector on the unit circle.\n     * @returns {Vector2} The generated vector.\n     */\n    static RandomOnCircle() {\n        const theta = Math.random() * Math.PI * 2;\n        return new Vector2(Math.sin(theta), Math.cos(theta));\n    }\n    /**\n     * Generates a random vector within the unit circle.\n     * @returns {Vector2} The generated vector.\n     */\n    static RandomInCircle() {\n        const theta = Math.random() * Math.PI * 2;\n        const r = Math.random();\n        return new Vector2(r * Math.sin(theta), r * Math.cos(theta));\n    }\n    /**\n     * Checks if two vectors are equal within a tolerance.\n     * @param {Vector2} v1 - The first vector.\n     * @param {Vector2} v2 - The second vector.\n     * @param {number} [tolerance=MathU.DefaultErrorMargin] - The tolerance for equality.\n     * @returns {boolean} True if the vectors are equal within the tolerance, false otherwise.\n     */\n    static Equals(v1, v2, tolerance = _utility__WEBPACK_IMPORTED_MODULE_0__.MathU.DefaultErrorMargin) {\n        return v1.equals(v2, tolerance);\n    }\n    /**\n     * Creates a copy of a vector.\n     * @param {Vector2} v1 - The vector to copy.\n     * @returns {Vector2} A copy of the input vector.\n     */\n    static Copy(v1) {\n        return new Vector2(v1.x, v1.y);\n    }\n}\n\n\n//# sourceURL=webpack://@max_feige/canvas-utils/./src/math/vector2.ts?");

/***/ }),

/***/ "./src/rendering/canvas.ts":
/*!*********************************!*\
  !*** ./src/rendering/canvas.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasRenderer: () => (/* binding */ CanvasRenderer)\n/* harmony export */ });\n/* harmony import */ var _math_transform2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/transform2d */ \"./src/math/transform2d.ts\");\n/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vector2 */ \"./src/math/vector2.ts\");\n\n\nclass CanvasRenderer {\n    constructor(canvas, pixelsPerUnit = 100) {\n        this.canvas = canvas;\n        this.pixelsPerUnit = pixelsPerUnit;\n        this.canvasTransform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Identity;\n        this.worldTransform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Identity;\n        const maybeContext = canvas.getContext(\"2d\");\n        if (maybeContext === null) {\n            throw new Error(\"Could not create 2d context\");\n        }\n        this.ctx = maybeContext;\n        this._onCanvasResize();\n        window.addEventListener(\"resize\", this._onCanvasResize.bind(this));\n    }\n    //TODO: Consider storing inverse and multiples or calculating each frame instead of calculating each time we transform\n    tWindowToCanvas(point) {\n        return _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.ApplyPoint(this.canvasTransform, point);\n    }\n    tWindowToWorld(point) {\n        return _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.ApplyPoint(_math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Apply(this.worldTransform, this.canvasTransform), point);\n    }\n    tCanvasToWorld(point) {\n        return _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.ApplyPoint(this.worldTransform, point);\n    }\n    tCanvasToWindow(point) {\n        const inverseCanvasTransform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Inverse(this.canvasTransform);\n        return inverseCanvasTransform.applyPoint(point);\n    }\n    tWorldToCanvas(point) {\n        const inverseWorldTransform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Inverse(this.worldTransform);\n        return inverseWorldTransform.applyPoint(point);\n    }\n    tWorldToWindow(point) {\n        const inverseCanvasTransform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Inverse(this.canvasTransform);\n        const inverseWorldTransform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Inverse(this.worldTransform);\n        return _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.ApplyPoint(_math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Apply(inverseCanvasTransform, inverseWorldTransform), point);\n    }\n    drawText(position, text) {\n        const canvasPosition = this.tWindowToCanvas(position);\n        return this.ctx.fillText(text, canvasPosition.x, canvasPosition.y);\n    }\n    drawLine(from, to) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(...this.tWorldToCanvas(from).toArray());\n        this.ctx.lineTo(...this.tWorldToCanvas(to).toArray());\n        this.ctx.stroke();\n    }\n    clear() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n    _onCanvasResize() {\n        this.canvasTransform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.Identity;\n        const rect = this.canvas.getBoundingClientRect();\n        this.canvas.width = rect.width;\n        this.canvas.height = rect.height;\n        this.canvasTransform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.FromPosition(new _math_vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2(-rect.left, -rect.top));\n        const worldScale = new _math_vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2(1 / this.pixelsPerUnit, 1 / this.pixelsPerUnit);\n        this.worldTransform = _math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.FromPosition(new _math_vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2(-rect.width / 2, -rect.height / 2));\n        this.worldTransform.applyS(_math_transform2d__WEBPACK_IMPORTED_MODULE_0__.Transform2D.FromScalar(worldScale));\n        console.log(this.canvasTransform.toString());\n        console.log(this.worldTransform.toString());\n    }\n}\n\n\n//# sourceURL=webpack://@max_feige/canvas-utils/./src/rendering/canvas.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./examples/main.ts");
/******/ 	
/******/ })()
;